# 开发记录

### 开发注意事项

1. Select选择器 clearable 将参数置为null，需处理为 ''，封装transformParams方法处理
2. encodeURIComponent处理查询字段输入特殊符号 %.. 等，避免调用时接口报错
3. 搜索时不要直接绑定params中的值，绑定另外一个searchKey，保证在删除关键字，点击下一页时不会报错
4. removeEventlistener 不能移除匿名函数，可以使用 document.onclick = fn 的方式绑定，并且在beforeDestroy钩子函数中移除事件 document.onclick = null，需要注意的时，这种方式不能绑定多个事件处理函数，如一个页面中某个组件使用了多次，并且都绑定了window.onscroll = fn ，那么最后一个组件中绑定的事件处理函数会覆盖前面几个组件的处理函数，这个时候应该使用 addEventlistener 来绑定事件。

### 部署博客

"scripts": {

 	 "upload": "pscp.exe -p -r -v -scp -pw 8+Cd7kNJQpprzM?7  ./public root@149.28.81.196:/usr/src/blog/"

  }

### VSCode配置Vue项目的开发环境

1、VSCode 安装 Vue.js Extension Pack 插件

2、在项目中安装 ESlint

```json
# Add these to dev dependies of your project `package.json`.
"eslint": "^3.19.0",
"eslint-friendly-formatter": "^2.0.7",
"eslint-loader": "^1.7.1",
"eslint-plugin-html": "^2.0.0",
"eslint-config-standard": "^6.2.1",
"eslint-plugin-promise": "^3.4.0",
"eslint-plugin-standard": "^2.0.1"`
```

3、配置 ESLint

- VSCode 的配置

`Ctrl + P,`打开 settings.json文件，添加下面的配置

```
"eslint.enable": true, //Enable eslint
"eslint.options": {
"extensions": [ //List of file extensions to activate eslint
  ".html",
  ".js",
  ".vue",
  ".jsx"
  ]
},
"eslint.validate": [{ //list of extensions to validate
  "language": "html",
  "autoFix": true
},
{
  "language": "vue",
  "autoFix": true //Autofix any fixable errors when linting
},
{
  "language": "javascript",
  "autoFix": true
},
{
  "language": "javascriptreact",
  "autoFix": true
}
],
// Run the linter on save (onSave) or on type (onType)
"eslint.run": "onSave",
"eslint.autoFixOnSave": true //Autofix any fixable errors when linting
```

- 配置 .eslintrc.js

```
{
  "env": {
    "browser": true,
    "commonjs": true,
    "es6": true,
    "node": true
  },
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    },
    "sourceType": "module"
  },
  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style
  "extends": "standard",
  // required to lint *.vue files
  "plugins": [
    "html"
  ],
  "rules": {
    "no-const-assign": "warn",
    "no-this-before-super": "warn",
    "no-undef": "warn",
    "no-unreachable": "warn",
    "no-unused-vars": "warn",
    "constructor-super": "warn",
    "valid-typeof": "warn"
  }
}
```

### 使用 es6-promise 扩展 Promise

```javascript
# es6-promise是个库而已，不会自动 polyfill; 要想自动 polyfill 那么就用 es6-promise.auto

// main.js
# es6-promise.auto 会检测 Promise 是否存在，若存在原生的Promise，则不执行；否则会应用 polyfill;
import 'es6-promise/auto'

# 扩展Promise.finally方法
function polyfill () {
  var local
  if (typeof global !== 'undefined') {
    local = global
  } else if (typeof self !== 'undefined') {
    local = self
  }
  local.Promise.prototype['finally'] = function (callback) {
    let P = this.constructor
    return this.then(
      value => P.resolve(callback()).then(() => value),
      reason => P.resolve(callback()).then(() => {
        throw reason
      })
    )
  }
}
polyfill()
```

### babel-polyfill

babel 只负责语法转换，比如将ES6的语法转换成ES5。但如果有些对象、方法，浏览器本身不支持，比如：

1. 全局对象：Promise、WeakMap 等。
2. 全局静态函数：Array.from、Object.assign 等。
3. 实例方法：比如 Array.prototype.includes 等。

此时，需要引入`babel-polyfill`来模拟实现这些对象、方法。

`babel-polyfill`主要包含了`core-js`和`regenerator`两部分。

- core.js：提供了如ES5、ES6、ES7等规范中 新定义的各种对象、方法的模拟实现。
- regenerator：提供 generator 支持，如果应用代码中用到 generator、async 函数的话需要用到。

**`babel-polyfill`实现的Promise对象扩展了finally方法，引用后不需要再使用es6-promise扩展`Promise.finally`(在ES2018中finally方法已经成为了标准)**

### vue项目使用Nprogress进度条

安装

    yarn add nprogress

在项目中引入

```
// 在main.js中引入要使用的nprogress
import NProgress from 'nprogress'
```

基本用法

```
  NProgress.start(); 
  NProgress.done(); 
```

在路由页面跳转使用

```
  router.beforeEach((to, from, next) => {
    NProgress.start()
    if (getToken()) {
      if (to.path === '/login') {
        next({path: '/home'})
        NProgress.done()
      } else {
        if (to.meta.noLogin) {
          next()
        } else {
          if (!store.state.user.isLogin) {
            store.dispatch('getUserInfo').then(res => {
              next()
            }).catch(() => {
              Message.error('验证失败，请重新登录')
              next({ path: '/login' })
            })
          } else {
            next()
          }
        }
      }
    } else {
      if (to.meta.noLogin) {
        next()
      } else {
        next('/login')
        NProgress.done()
      }
    }
  })

  router.afterEach((route) => {
    NProgress.done() // 结束Progress
  })
```

### moment 设置常用日期

```
// 今天
moment().startOf('day').format('YYYY-MM-DD HH:mm:ss')
moment().endOf('day').format('YYYY-MM-DD HH:mm:ss')

// 昨天
moment().subtract(1, 'days').startOf('day').format('YYYY-MM-DD HH:mm:ss') 
moment().subtract(1, 'days').endOf('day').format('YYYY-MM-DD HH:mm:ss')

// 过去七天
moment().subtract(6, 'days').startOf('days').format('YYYY-MM-DD HH:mm:ss') 
moment().endOf('days').format('YYYY-MM-DD HH:mm:ss')

// 默认30天
moment().subtract(29, 'days').format('YYYY-MM-DD HH:mm:ss')
moment().format('YYYY-MM-DD HH:mm:ss')

// 默认这个月
moment().startOf('month').format('YYYY-MM-DD HH:mm:ss')
moment().endOf('month').format('YYYY-MM-DD HH:mm:ss')

//默认上个月
moment().subtract(1, 'month').startOf('month').format('YYYY-MM-DD HH:mm:ss')
moment().subtract(1, 'month').endOf('month').format('YYYY-MM-DD HH:mm:ss')
```

### Vux基本使用

Vux（读音 [v'ju:z]，同views）是基于WeUI和Vue(2.x)开发的移动端UI组件库，主要服务于微信页面。

**1. 安装vux**

```
yarn add vux
```

**2. 安装less-loader**

vux使用less编译源码，所以项目里必须要有less-loader

```
yarn add less less-loader -D
```

**3. 安装vux-loader**

```
yarn add vux-loader
```

你可以不安装不配置vux-loader，不配置的话引入组件是这样的：

```
import AlertPlugin from 'vux/src/plugins/Alert'
import ToastPlugin from 'vux/src/plugins/Toast'
```

配置之后就可以这样引入组件了：

```
import { AlertPlugin, ToastPlugin } from 'vux'
```

**vux-loader保证了组件按需使用，因此不用担心最终打包了整个vux的组件库代码。** 

**4.webpack配置**

为了降低使用成本及不侵入原来配置，只需要调用`merge`方法对原来`webpack`配置进行操作： 

```
const vuxLoader = require('vux-loader')
module.exports = vuxLoader.merge(webpackConfig, {
  plugins: [
    {
      name: 'vux-ui'
    },
    {
      name: 'duplicate-style',
      options: {
        cssProcessorOptions : {
          safe: true,
          zindex: false,
          autoprefixer: {
            add: true,
            "browsers": [
              "iOS >= 7",
              "Android >= 4.1"
            ]
          }
        }
      }
    },
    {
      name: 'less-theme',
      path: 'src/vux-theme.less'
    }
  ]
})
```
### 访问原生DOM事件event

```
事件处理时访问原生DOM事件event有下面两种情况：

1、绑定事件处理函数： 默认会把$event作为处理函数的第一个参数传入
handle（event） {
  console.log(event)
}

2、直接调用事件处理函数，需要手动把$event传入到处理函数中
<button v-on:click="handle(payload， $event)">Say what</button>
handle（payload, event） {
  console.log(event)
}
```

### 移动端尺寸适配问题

**微信小程序**

微信小程序以 rpx（responsive pixel）为单位，可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。 开发时以iPhone6作为视觉稿的标准，宽度为 750px。所以开发时 1px = 1rpx，对于部分不需要自适应的高度，可以直接使用px作为单位。

**webapp**

webapp的适配使用的是rem，通常我们会设置 viewport 禁用屏幕缩放，防止用户缩放之后页面样式错乱。同时监听 resize 事件，动态修改 document 元素的fontSiz，实现适配。

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
```

```javascript
export const setRemRatio = function () {
  var tid
  var docEl = document.documentElement
  var refreshRem = function () {
    var clientWidth = docEl.clientWidth < 750 ? docEl.clientWidth : 750
    var rem = clientWidth / 750
    docEl.style.fontSize = (rem * 100) + 'px'
  }
  window.addEventListener('resize', function () {
    clearTimeout(tid)
    tid = setTimeout(refreshRem, 300)
  }, false)
  refreshRem()
}
```

在开发时以iPhone6作为视觉稿的标准，宽度为 750px，7.5 rem 屏幕宽度为100%，所以在进行rem换算时，以**设计稿为标准，只需要除以100即可。**

**RN App**

RN以点（point）作为单位，通过Dimensions.get方法可以获取到屏幕宽高，以iPhone6来说，屏幕宽度为375pt，而设计稿为750px，所以需要除以2。对于不同的屏幕宽度，我们需要适当调整尺寸大小，可以封装一个函数处理。

```javascript
const { width, height } = Dimensions.get('window')
```

```javascript
import { Dimensions } from 'react-native'

const { width, height } = Dimensions.get('window')

const screenWidth = width < height ? width : height

const basePx = 375

// 这里的px2dp只是方法名，不是用来换算
export default function px2dp (px) {
  return px * screenWidth / basePx
}
```

### webpack中 NODE_ENV 的配置

在 `package.json` 中我们通过会使用 `cross-env NODE_ENV=production` 来设置开发环境，在 windows 平台下使用类似于: `NODE_ENV=production`的命令会报错，所以 需要安装 cross-env 模块，作用是用来跨平台设置环境变量。这里设置完之后只能在 webpack 的配置的时候(Node环境)拿到 `NODE_ENV `这个变量，要是想在Vue代码中使用，需要通过`webpack.DefinePlugin` 这个插件来实现。

```javascript
new webpack.DefinePlugin({
  'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development')
}),
```

**说明：在 webpack4 中新增了一个 mode 配置，这个是给 webpack 用的，webpack 会根据 mode值来进行一些相应的处理。**

```
let webpackConfig = {
  mode: process.env.NODE_ENV || 'development',
 }
```

### nginx作代理时，查看请求被转发到哪台服务器		

使用Nginx代理多台服务器实行负载的时候，如何查看某一个请求被转发到哪台服务器上呢？

```
upstream demo { 
     server 127.0.0.1:8781;
     server 127.0.0.1:8087;
}
```

加上如下配置：

```
server {
    listen       80;
    server_name  demo.testcas.com;
    #charset koi8-r;
    #access_log  logs/host.access.log  main;

	location / {
        #root   html;
        #index  index.html index.htm;
        add_header backendIP $upstream_addr;
        add_header backendCode $upstream_status;
        proxy_pass http://demo;
    }
}
```

### nginx反向代理，node获取真实IP		

node的前端放了一个 [nginx](https://www.baidu.com/s?wd=nginx&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd) 做反向代理，结果 req.ip 始终取到 nginx 的IP，为了取得客户端真实IP，需要做2件事： 

1. 设置nginx转发时加上http header

2. 在node中取出新加的header

nginx配置

```nginx
location /svc/ {
    proxy_pass http://192.168.1.111:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
```

 这里增加了3个http header，其中X-Real-IP代表真实IP 

node代码

```javascript
var real_ip = req.get("X-Real-IP") || req.get("X-Forwarded-For") || req.ip;
```

### node_sass安装失败问题

```bash
# 第一步 配置 node-sass 的二进制包镜像地址：
yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ --global

# 第二步 重新安装 node-sass 依赖
yarn add node-sass@xxx -D
```

### node下载指定版本

```
# 修改版本号即可
https://nodejs.org/download/release/v8.10.0/
```

### 路由组件按需加载的几种方法

1. webpack提供的 require.ensure()

```javascript
const lottery = resolve => require.ensure([], () => resolve(require('@/pages/lottery')))
{ 
	path: '/lottery', 
	name: 'lottery', 
	component: lottery
}
```

2. Vue的 [异步组件技术 ](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6) 配合 webpack 的 code-splitting 功能一起配合使用，这种方法可以实现按需加载，并且组件单独打包成一个 js文 件

```javascript
{
    path: 'home',
    name: 'home',
    component: resolve => require(['@/pages/home'], resolve)
}
```

3. [ECMAScript 提案](https://github.com/tc39/proposal-dynamic-import) 的 [`import()` 语法](https://webpack.docschina.org/api/module-methods#import-) 

```javascript
const login = () => import('@/pages/login')
```

### axios跨域请求带上cookies

前端设置

```javascript
# `withCredentials` 表示跨域请求时是否需要使用凭证
withCredentials: true, // 默认的
```

后台设置

```javascript
# 注意不能设置为 *
Access-Control-Allow-Origin: 'http://localhost:8080'
```

注：配置proxyTable后不需要这样处理，请求会被代理出去，不存在跨域问题

### 解决vue项目中的 Invalid Host header

vue-cli 2.x，修改 `webpack.dev.conf.js`中的 devServer 对象，加入disableHostCheck: true

```javascript
devServer: {
  disableHostCheck: true,
}
```

vue-cli 3.0，修改`vue.config.js`的配置

```javascript
module.exports = {
  devServer: {
    disableHostCheck: true
  }
}
```

使用 el-scrollbar 组件后回到顶部

```html
<template>
  <!--transition标签 按钮出现附带动画-->
  <transition name="el-fade-in">
    <div class="page-component-up" @click="scrollToTop" v-show="toTopShow">
      <i class="el-icon-caret-top"></i>
    </div>
  </transition>
</template>

<script>
  export default {
    data() {
      return {
        toTopShow: false,
      }
    },
    methods: {
      handleScroll() {
        //id scroller-box是自己在组件上添加的，为了方便获取dom
        this.scrollTop = document.getElementById("scroller-box").children[0].scrollTop
        if (this.scrollTop > 300) {
          this.toTopShow = true
        }else {
          this.toTopShow = false
        }
      },
      scrollToTop() {
        let timer = null, _that = this
        //动画，使用requestAnimationFrame代替setInterval
        cancelAnimationFrame(timer)
        timer = requestAnimationFrame(function fn() {
          if (_that.scrollTop > 0) {
            _that.scrollTop -= 50
            document.getElementById("scroller-box").children[0].scrollTop = _that.scrollTop
            timer = requestAnimationFrame(fn)
          } else {
            cancelAnimationFrame(timer)
            _that.toTopShow = false
          }
        })
      }
    },
    mounted() {
　　　　//$nextTick 避免dom未加载
      this.$nextTick(function () {
        let targetScroll = document.getElementById("scroller-box").children[0]
        targetScroll.addEventListener('scroll', this.handleScroll)
      });
    },
    destroyed() {
      let targetScroll = document.getElementById("scroller-box").children[0]
      targetScroll.removeEventListener('scroll', this.handleScroll)
    }
  }
</script>
<style scoped lang="scss">
  .page-component-up{
    background-color: #409eff;
    position: fixed;
    right: 100px;
    bottom: 150px;
    width: 40px;
    height: 40px;
    border-radius: 20px;
    cursor: pointer;
    transition: .3s;
    box-shadow: 0 3px 6px rgba(0, 0, 0, .5);
    z-index: 100;
    .el-icon-caret-top{
      color: #fff;
      display: block;
      line-height: 40px;
      text-align: center;
      font-size: 18px;
    }
    p{
      display: none;
      text-align: center;
      color: #fff;
    }
    &:hover{
      opacity: .8;
    }
  }
</style>
```

### Vue项目中使用RSA加密

```bash
yarn add jsencrypt
```

```js
import JSEncrypt from 'jsencrypt'

// 公钥
let publicKey = `MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDHGBAi30CuorD71ddAY5Pj80a2
    FinTK6CJrX3LJZ5FTxJrQdzxbwDVB2mDVgspU5oz7X03TzgWFKkkJm2b4g9G00sA
    +G9oeGaR+rpFaoDr4BxW+AUd6V1Ps/OkTaLc473XOA0aYTRIwo1Ob3pTJd9Za90e
    +NRk0c07Vb/mcr0w1QIDAQAB`
 
// 封装函数
encrypt (publicKey, key){
	let encryptor = new JSEncrypt()
	encryptor.setPublicKey(publicKey) // 设置公钥
	let rsaKey = encryptor.encrypt(key) // 对需要加密的数据进行加密
    return rsaKey
 }
 
```

